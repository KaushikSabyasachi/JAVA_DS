import java.util.*;

public class ARRAY_SUBARY_SUM_DIV_k {
public static void main(String args[]) {
		
		Scanner SC = new Scanner(System.in);
		
		int T = SC.nextInt(); // LENGTH OF THE ARRAY 
		int [] nums = new int[T]; // ARRAY SIZE OF LENGTH 
		
		for (int i=0;i<T;i++) { nums[i]= SC.nextInt();} // INPUTS OF ARRAY
		
		int k = SC.nextInt(); //Number that ll be used for comparisions
		

		        // Use the HashMap to record the frequency of all the prefix sum remainders.
		        Map<Integer, Integer> map = new HashMap<>();
		        for (int i = 0, remainder; i < nums.length; i++) {
		            if (i > 0) nums[i] += nums[i - 1];
		            // Note that the integer in 'nums' can be negative.
		            // Thus, we need to adjust the negative remainder to positive remainder.
		            // Below accounts for both negative and positive remainders.
		            // We can also check if the remainder is negative, then add a 'k' to make the remainder positive.
		            // For Example, nums = [-2,3,2], k = 5,
		            // remainder for the prefix sum of [-2,1,3] are -2, 1 and 3 respectively.
		            // We know that [3,2] sum to 5, which is divisible by 5.
		            // After converting -2 to 3, by adding 5, it has the same remainder with prefix sum 3.
		            remainder = (nums[i] % k + k) % k;
		            map.put(remainder, map.getOrDefault(remainder, 0) + 1);
		        }
		        // The result contains all the prefix sum with remainder 0,
		        // as all the prefix sum with remainder of 0 is itself divisible by 'k'.
		        // However, do note that the prefix sum with remainder 0 also able to form subarray sums that is divisible by 'k'
		        // with one another, which will be calculated next.
		        // For Example: nums = [5,5,5,5], k = 5,
		        // The prefix sum of [5,10,15,20] are themselves divisible by 5, while also forming subarray sums divisible by 5
		        // with 10 [5,5] - 5 [5] == 5, 15 [5,5,5] - 5 [5] == 10, etc.
		        int result = map.getOrDefault(0, 0);

		        // The prefix sums with the same remainder can form subarray sums that is divisible by 'k' with each other.
		        // For each remainder, the number of subarray that is divisible by 'k' is the number of combinations from the frequency.
		        // Equation for the number of combinations of n items is n * "(n - 1) / 2".
		        for (int frequency : map.values())
		            result += frequency * (frequency - 1) / 2;

		        System.out.println(result);
		    }
		}

